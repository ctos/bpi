Do not --enable-ide-forcedma by default, it's too dangerous on non-DMA
supporting hardware.

2004-09-17  Sergio Lopez  <koro@sinrega.org>


Index: b/linux/src/drivers/block/ide.c
===================================================================
--- a/linux/src/drivers/block/ide.c
+++ b/linux/src/drivers/block/ide.c
@@ -3594,9 +3594,6 @@ static void ide_probe_promise_20246(void
 		hwif->ctl_port = io[tmp + 1] + 2;
 		hwif->noprobe = 0;
 	}
-#ifdef CONFIG_BLK_DEV_TRITON
-	ide_init_promise (bus, fn, &ide_hwifs[2], &ide_hwifs[3], io[4]);
-#endif /* CONFIG_BLK_DEV_TRITON */
 }
 
 #endif /* CONFIG_PCI */
@@ -3629,6 +3626,9 @@ static void probe_for_hwifs (void)
 		ide_probe_pci (PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371_0, &ide_init_triton, 1);
 		ide_probe_pci (PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371SB_1, &ide_init_triton, 0);
 		ide_probe_pci (PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB, &ide_init_triton, 0);
+		ide_probe_pci (PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_5513, &ide_init_triton, 0);
+		ide_probe_pci (PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C586_1, &ide_init_triton, 0);
+		ide_probe_pci (PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M5229, &ide_init_triton, 0);
 #endif /* CONFIG_BLK_DEV_TRITON */
 		ide_probe_promise_20246();
 	}
@@ -3703,8 +3703,9 @@ int ide_init (void)
 
 	init_ide_data ();
 	/*
-	 * Probe for special "known" interface chipsets
+	 * Probe for special "known" interface chipsets.
 	 */
+	 
 	probe_for_hwifs ();
 
 	/*
Index: b/linux/src/drivers/block/ide.h
===================================================================
--- a/linux/src/drivers/block/ide.h
+++ b/linux/src/drivers/block/ide.h
@@ -429,7 +429,8 @@ typedef void (ide_selectproc_t) (ide_dri
 typedef enum {	ide_unknown,	ide_generic,	ide_triton,
 		ide_cmd640,	ide_dtc2278,	ide_ali14xx,
 		ide_qd6580,	ide_umc8672,	ide_ht6560b,
-		ide_promise,	ide_promise_udma }
+		ide_promise,	ide_hpt343,	ide_udma,
+		ide_ultra66 }
 	hwif_chipset_t;
 
 typedef struct hwif_s {
Index: b/linux/src/drivers/block/triton.c
===================================================================
--- a/linux/src/drivers/block/triton.c
+++ b/linux/src/drivers/block/triton.c
@@ -1,107 +1,20 @@
 /*
  *  linux/drivers/block/triton.c	Version 1.13  Aug 12, 1996
+ *					Version 1.13a June 1998 - new chipsets
+ *					Version 1.13b July 1998 - DMA blacklist
+ *					Version 1.14  June 22, 1999
  *
+ *  Copyright (c) 1998-1999  Andre Hedrick
  *  Copyright (c) 1995-1996  Mark Lord
  *  May be copied or modified under the terms of the GNU General Public License
  */
 
 /*
- * This module provides support for the Bus Master IDE DMA function
- * of the Intel PCI Triton I/II chipsets (i82371FB or i82371SB).
- *
- * Pretty much the same code will work for the OPTi "Viper" chipset.
- * Look for DMA support for this in linux kernel 2.1.xx, when it appears.
- *
- * DMA is currently supported only for hard disk drives (not cdroms).
- *
- * Support for cdroms will likely be added at a later date,
- * after broader experience has been obtained with hard disks.
- *
- * Up to four drives may be enabled for DMA, and the Triton chipset will
- * (hopefully) arbitrate the PCI bus among them.  Note that the i82371 chip
- * provides a single "line buffer" for the BM IDE function, so performance of
- * multiple (two) drives doing DMA simultaneously will suffer somewhat,
- * as they contest for that resource bottleneck.  This is handled transparently
- * inside the i82371 chip.
- *
- * By default, DMA support is prepared for use, but is currently enabled only
- * for drives which support multi-word DMA mode2 (mword2), or which are
- * recognized as "good" (see table below).  Drives with only mode0 or mode1
- * (single or multi) DMA should also work with this chipset/driver (eg. MC2112A)
- * but are not enabled by default.  Use "hdparm -i" to view modes supported
- * by a given drive.
- *
- * The hdparm-2.4 (or later) utility can be used for manually enabling/disabling
- * DMA support, but must be (re-)compiled against this kernel version or later.
- *
- * To enable DMA, use "hdparm -d1 /dev/hd?" on a per-drive basis after booting.
- * If problems arise, ide.c will disable DMA operation after a few retries.
- * This error recovery mechanism works and has been extremely well exercised.
- *
- * IDE drives, depending on their vintage, may support several different modes
- * of DMA operation.  The boot-time modes are indicated with a "*" in
- * the "hdparm -i" listing, and can be changed with *knowledgeable* use of
- * the "hdparm -X" feature.  There is seldom a need to do this, as drives
- * normally power-up with their "best" PIO/DMA modes enabled.
- *
- * Testing was done with an ASUS P55TP4XE/100 system and the following drives:
- *
- *   Quantum Fireball 1080A (1Gig w/83kB buffer), DMA mode2, PIO mode4.
- *	- DMA mode2 works well (7.4MB/sec), despite the tiny on-drive buffer.
- *	- This drive also does PIO mode4, at about the same speed as DMA mode2.
- *	  An awesome drive for the price!
- *
- *   Fujitsu M1606TA (1Gig w/256kB buffer), DMA mode2, PIO mode4.
- *	- DMA mode2 gives horrible performance (1.6MB/sec), despite the good
- *	  size of the on-drive buffer and a boasted 10ms average access time.
- *	- PIO mode4 was better, but peaked at a mere 4.5MB/sec.
- *
- *   Micropolis MC2112A (1Gig w/508kB buffer), drive pre-dates EIDE and ATA2.
- *	- DMA works fine (2.2MB/sec), probably due to the large on-drive buffer.
- *	- This older drive can also be tweaked for fastPIO (3.7MB/sec) by using
- *	  maximum clock settings (5,4) and setting all flags except prefetch.
- *
- *   Western Digital AC31000H (1Gig w/128kB buffer), DMA mode1, PIO mode3.
- *	- DMA does not work reliably.  The drive appears to be somewhat tardy
- *	  in deasserting DMARQ at the end of a sector.  This is evident in
- *	  the observation that WRITEs work most of the time, depending on
- *	  cache-buffer occupancy, but multi-sector reads seldom work.
- *
- * Testing was done with a Gigabyte GA-586 ATE system and the following drive:
- * (Uwe Bonnes - bon@elektron.ikp.physik.th-darmstadt.de)
- *
- *   Western Digital AC31600H (1.6Gig w/128kB buffer), DMA mode2, PIO mode4.
- *	- much better than its 1Gig cousin, this drive is reported to work
- *	  very well with DMA (7.3MB/sec).
- *
- * Other drives:
- *
- *   Maxtor 7540AV (515Meg w/32kB buffer), DMA modes mword0/sword2, PIO mode3.
- *	- a budget drive, with budget performance, around 3MB/sec.
- *
- *   Western Digital AC2850F (814Meg w/64kB buffer), DMA mode1, PIO mode3.
- *	- another "caviar" drive, similar to the AC31000, except that this one
- *	  worked with DMA in at least one system.  Throughput is about 3.8MB/sec
- *	  for both DMA and PIO.
- *
- *   Conner CFS850A (812Meg w/64kB buffer), DMA mode2, PIO mode4.
- *	- like most Conner models, this drive proves that even a fast interface
- *	  cannot improve slow media.  Both DMA and PIO peak around 3.5MB/sec.
- *
- *   Maxtor 71260AT (1204Meg w/256kB buffer), DMA mword0/sword2, PIO mode3.
- *	- works with DMA, on some systems (but not always on others, eg. Dell),
- *	giving 3-4MB/sec performance, about the same as mode3.
- *
- * If you have any drive models to add, email your results to:  mlord@pobox.com
- * Keep an eye on /var/adm/messages for "DMA disabled" messages.
- *
- * Some people have reported trouble with Intel Zappa motherboards.
- * This can be fixed by upgrading the AMI BIOS to version 1.00.04.BS0,
- * available from ftp://ftp.intel.com/pub/bios/10004bs0.exe
- * (thanks to Glen Morrell <glen@spin.Stanford.edu> for researching this).
- *
- * And, yes, Intel Zappa boards really *do* use the Triton IDE ports.
+ * This module provides support for Bus Master IDE DMA functions in various
+ * motherboard chipsets and PCI controller cards.
+ * Please check /Documentation/ide.txt and /Documentation/udma.txt for details.
  */
+
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
@@ -116,10 +29,24 @@
 
 #include <asm/io.h>
 #include <asm/dma.h>
+#include <asm/irq.h>
 
 #include "ide.h"
 
 #undef DISPLAY_TRITON_TIMINGS	/* define this to display timings */
+#undef DISPLAY_APOLLO_TIMINGS	/* define this for extensive debugging information */
+#undef DISPLAY_ALI15X3_TIMINGS	/* define this for extensive debugging information */
+
+#if defined(CONFIG_PROC_FS)
+#include <linux/stat.h>
+#include <linux/proc_fs.h>
+#ifdef DISPLAY_APOLLO_TIMINGS
+#include <linux/via_ide_dma.h>
+#endif
+#ifdef DISPLAY_ALI15X3_TIMINGS
+#include <linux/ali_ide_dma.h>
+#endif
+#endif
 
 /*
  * good_dma_drives() lists the model names (from "hdparm -i")
@@ -132,6 +59,27 @@ const char *good_dma_drives[] = {"Microp
 				 NULL};
 
 /*
+ * bad_dma_drives() lists the model names (from "hdparm -i")
+ * of drives which supposedly support (U)DMA but which are
+ * known to corrupt data with this interface under Linux.
+ *
+ * Note: the list was generated by statistical analysis of problem
+ * reports. It's not clear if there are problems with the drives,
+ * or with some combination of drive/controller or what. 
+ *
+ * You can forcibly override this if you wish. This is the kernel
+ * 'Tread carefully' list.
+ *
+ * Finally see http://www.wdc.com/quality/err-rec.html if you have
+ * one of the listed drives. 
+ */
+const char *bad_dma_drives[] = {"WDC AC11000H",
+				"WDC AC22100H",
+				"WDC AC32500H",
+				"WDC AC33100H",
+				 NULL};
+
+/*
  * Our Physical Region Descriptor (PRD) table should be large enough
  * to handle the biggest I/O request we are likely to see.  Since requests
  * can have no more than 256 sectors, and since the typical blocksize is
@@ -150,6 +98,8 @@ const char *good_dma_drives[] = {"Microp
 #define PRD_BYTES	8
 #define PRD_ENTRIES	(PAGE_SIZE / (2 * PRD_BYTES))
 #define DEFAULT_BMIBA	0xe800	/* in case BIOS did not init it */
+#define DEFAULT_BMCRBA  0xcc00  /* VIA's default value */
+#define DEFAULT_BMALIBA	0xd400	/* ALI's default value */
 
 /*
  * dma_intr() is the handler for disk read/write DMA interrupts
@@ -161,8 +111,8 @@ static void dma_intr (ide_drive_t *drive
 	struct request *rq = HWGROUP(drive)->rq;
 	unsigned short dma_base = HWIF(drive)->dma_base;
 
-	dma_stat = inb(dma_base+2);		/* get DMA status */
 	outb(inb(dma_base)&~1, dma_base);	/* stop DMA operation */
+	dma_stat = inb(dma_base+2);		/* get DMA status */
 	stat = GET_STAT();			/* get drive status */
 	if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
 		if ((dma_stat & 7) == 4) {	/* verify good DMA status */
@@ -244,23 +194,57 @@ static int build_dmatable (ide_drive_t *
 	return 1;	/* let the PIO routines handle this weirdness */
 }
 
+/*
+ * We will only enable drives with multi-word (mode2) (U)DMA capabilities,
+ * and ignore the very rare cases of drives that can only do single-word
+ * (modes 0 & 1) (U)DMA transfers. We also discard "blacklisted" hard disks.
+ */
 static int config_drive_for_dma (ide_drive_t *drive)
 {
+#ifndef CONFIG_BLK_DEV_FORCE_DMA
 	const char **list;
 	struct hd_driveid *id = drive->id;
+#endif
+
+#ifdef CONFIG_BLK_DEV_FORCE_DMA
+	drive->using_dma = 1;
+	return 0;
+#else
+	if (HWIF(drive)->chipset == ide_hpt343) {
+		drive->using_dma = 0;	/* no DMA */
+		return 1;	/* DMA disabled */
+	}
 
 	if (id && (id->capability & 1)) {
-		/* Enable DMA on any drive that has UltraDMA (mode 0/1/2) enabled */
-		if (id->field_valid & 4)	/* UltraDMA */
-			if  ((id->dma_ultra & (id->dma_ultra >> 8) & 7)) {
+		/* Consult the list of known "bad" drives */
+		list = bad_dma_drives;
+		while (*list) {
+			if (!strcmp(*list++,id->model)) {
+				drive->using_dma = 0;   /* no DMA */
+				printk("ide: Disabling DMA modes on %s drive (%s).\n", drive->name, id->model);
+				return 1;	/* DMA disabled */
+			}
+		}
+		/* Enable DMA on any drive that has mode 4 or 2 UltraDMA enabled */
+		if (id->field_valid & 4) {	/* UltraDMA */
+			/* Enable DMA on any drive that has mode 4 UltraDMA enabled */
+			if (((id->dma_ultra & 0x1010) == 0x1010) &&
+			    (id->word93 & 0x2000) &&
+			    (HWIF(drive)->chipset == ide_ultra66)) {
 				drive->using_dma = 1;
-				return 0;	/* dma enabled */
+				return 0;	/* DMA enabled */
+			} else
+			/* Enable DMA on any drive that has mode 2 UltraDMA enabled */
+				if ((id->dma_ultra & 0x404) == 0x404) {
+				drive->using_dma = 1;
+				return 0;	/* DMA enabled */
 			}
-		/* Enable DMA on any drive that has mode2 DMA (multi or single) enabled */
+		}
+		/* Enable DMA on any drive that has mode2 DMA enabled */
 		if (id->field_valid & 2)	/* regular DMA */
-			if  ((id->dma_mword & 0x404) == 0x404 || (id->dma_1word & 0x404) == 0x404) {
+			if ((id->dma_mword & 0x404) == 0x404) {
 				drive->using_dma = 1;
-				return 0;	/* dma enabled */
+				return 0;	/* DMA enabled */
 			}
 		/* Consult the list of known "good" drives */
 		list = good_dma_drives;
@@ -272,6 +256,7 @@ static int config_drive_for_dma (ide_dri
 		}
 	}
 	return 1;	/* DMA not enabled */
+#endif
 }
 
 /*
@@ -387,22 +372,260 @@ static void init_triton_dma (ide_hwif_t 
 }
 
 /*
+ *  Set VIA Chipset Timings for (U)DMA modes enabled.
+ */
+static int set_via_timings (byte bus, byte fn, byte post, byte flush)
+{
+	byte via_config = 0;
+	int rc = 0;
+
+	/* setting IDE read prefetch buffer and IDE post write buffer */
+	if ((rc = pcibios_read_config_byte(bus, fn, 0x41, &via_config)))
+		return (1);
+	if ((rc = pcibios_write_config_byte(bus, fn, 0x41, via_config | post)))
+		return (1);
+
+	/* setting Channel read and End-of-sector FIFO flush: */
+	if ((rc = pcibios_read_config_byte(bus, fn, 0x46, &via_config)))
+		return (1);
+	if ((rc = pcibios_write_config_byte(bus, fn, 0x46, via_config | flush)))
+		return (1);
+
+	return (0);
+}
+
+static int setup_aladdin (byte bus, byte fn)
+{
+	byte confreg0 = 0, confreg1 = 0, progif = 0;
+	int errors = 0;
+
+	if (pcibios_read_config_byte(bus, fn, 0x50, &confreg1))
+		goto veryspecialsettingserror;
+	if (!(confreg1 & 0x02))
+		if (pcibios_write_config_byte(bus, fn, 0x50, confreg1 | 0x02))
+			goto veryspecialsettingserror;
+
+	if (pcibios_read_config_byte(bus, fn, 0x09, &progif))
+		goto veryspecialsettingserror;
+	if (!(progif & 0x40)) {
+		/*
+		 * The way to enable them is to set progif
+		 * writable at 0x4Dh register, and set bit 6
+		 * of progif to 1:
+		 */
+		if (pcibios_read_config_byte(bus, fn, 0x4d, &confreg0))
+			goto veryspecialsettingserror;
+		if (confreg0 & 0x80)
+			if (pcibios_write_config_byte(bus, fn, 0x4d, confreg0 & ~0x80))
+				goto veryspecialsettingserror;
+		if (pcibios_write_config_byte(bus, fn, 0x09, progif | 0x40))
+			goto veryspecialsettingserror;
+		if (confreg0 & 0x80)
+			if (pcibios_write_config_byte(bus, fn, 0x4d, confreg0))
+				errors++;
+	}
+
+	if ((pcibios_read_config_byte(bus, fn, 0x09, &progif)) || (!(progif & 0x40)))
+		goto veryspecialsettingserror;
+
+	printk("ide: ALI15X3: enabled read of IDE channels state (en/dis-abled) %s.\n",
+		errors ? "with Error(s)" : "Succeeded" );
+	return 1;
+veryspecialsettingserror:
+	printk("ide: ALI15X3: impossible to enable read of IDE channels state (en/dis-abled)!\n");
+	return 0;
+}
+
+void set_promise_hpt343_extra (unsigned short device, unsigned int bmiba)
+{
+	switch(device) {
+		case PCI_DEVICE_ID_PROMISE_20246:
+			if(!check_region((bmiba+16), 16))
+				request_region((bmiba+16), 16, "PDC20246");
+			break;
+		case PCI_DEVICE_ID_PROMISE_20262:
+			if (!check_region((bmiba+48), 48))
+				request_region((bmiba+48), 48, "PDC20262");
+			break;
+		case PCI_DEVICE_ID_TTI_HPT343:
+			if(!check_region((bmiba+16), 16))
+				request_region((bmiba+16), 16, "HPT343");
+			break;
+		default:
+			break;
+	}
+}
+
+#define HPT343_PCI_INIT_REG		0x80
+
+/*
  * ide_init_triton() prepares the IDE driver for DMA operation.
  * This routine is called once, from ide.c during driver initialization,
- * for each triton chipset which is found (unlikely to be more than one).
+ * for each BM-DMA chipset which is found (rarely more than one).
  */
 void ide_init_triton (byte bus, byte fn)
 {
-	int rc = 0, h;
-	int dma_enabled = 0;
-	unsigned short pcicmd;
-	unsigned int bmiba, timings;
+	byte bridgebus, bridgefn, bridgeset = 0, hpt34x_flag = 0;
+	unsigned char irq = 0;
+	int dma_enabled = 0, rc = 0, h;
+	unsigned short io[6], count = 0, step_count = 0, pass_count = 0;
+	unsigned short pcicmd, vendor, device, class;
+	unsigned int bmiba, timings, reg, tmp;
+	unsigned int addressbios = 0;
+	unsigned long flags;
+	unsigned index;
+
+#if defined(DISPLAY_APOLLO_TIMINGS) || defined(DISPLAY_ALI15X3_TIMINGS)
+	bmide_bus = bus;
+	bmide_fn = fn;
+#endif /* DISPLAY_APOLLO_TIMINGS || DISPLAY_ALI15X3_TIMINGS */
+
+/*
+ *  We pick up the vendor, device, and class info for selecting the correct
+ *  controller that is supported.  Since we can access this routine more than
+ *  once with the use of onboard and off-board EIDE controllers, a method
+ *  of determining "who is who for what" is needed.
+ */
+
+	pcibios_read_config_word (bus, fn, PCI_VENDOR_ID, &vendor);
+	pcibios_read_config_word (bus, fn, PCI_DEVICE_ID, &device);
+	pcibios_read_config_word (bus, fn, PCI_CLASS_DEVICE, &class);
+	pcibios_read_config_byte (bus, fn, PCI_INTERRUPT_LINE, &irq);
+
+	switch(vendor) {
+		case PCI_VENDOR_ID_INTEL:
+			printk("ide: Intel 82371 ");
+			switch(device) {
+				case PCI_DEVICE_ID_INTEL_82371_0:
+					printk("PIIX (single FIFO) ");
+					break;
+				case PCI_DEVICE_ID_INTEL_82371SB_1:
+					printk("PIIX3 (dual FIFO) ");
+					break;
+				case PCI_DEVICE_ID_INTEL_82371AB:
+					printk("PIIX4 (dual FIFO) ");
+					break;
+				default:
+					printk(" (unknown) 0x%04x ", device);
+					break;
+			}
+			printk("DMA Bus Mastering IDE ");
+			break;
+		case PCI_VENDOR_ID_SI:
+			printk("ide: SiS 5513 (dual FIFO) DMA Bus Mastering IDE ");
+			break;
+                case PCI_VENDOR_ID_VIA:
+			printk("ide: VIA VT82C586B (split FIFO) UDMA Bus Mastering IDE ");
+			break;
+		case PCI_VENDOR_ID_TTI:
+			/*PCI_CLASS_STORAGE_UNKNOWN == class */
+			if (device == PCI_DEVICE_ID_TTI_HPT343) {
+				pcibios_write_config_byte(bus, fn, HPT343_PCI_INIT_REG, 0x00);
+				pcibios_read_config_word(bus, fn, PCI_COMMAND, &pcicmd);
+				hpt34x_flag = (pcicmd & PCI_COMMAND_MEMORY) ? 1 : 0;
+#if 1
+				if (!hpt34x_flag) {
+					save_flags(flags);
+					cli();
+					pcibios_write_config_word(bus, fn, PCI_COMMAND, pcicmd & ~PCI_COMMAND_IO);
+					pcibios_read_config_dword(bus, fn, PCI_BASE_ADDRESS_4, &bmiba);
+					pcibios_write_config_dword(bus, fn, PCI_BASE_ADDRESS_0, bmiba | 0x20);
+					pcibios_write_config_dword(bus, fn, PCI_BASE_ADDRESS_1, bmiba | 0x34);
+					pcibios_write_config_dword(bus, fn, PCI_BASE_ADDRESS_2, bmiba | 0x28);
+					pcibios_write_config_dword(bus, fn, PCI_BASE_ADDRESS_3, bmiba | 0x3c);
+					pcibios_write_config_word(bus, fn, PCI_COMMAND, pcicmd);
+					bmiba = 0;
+					restore_flags(flags);
+				}
+#endif
+				pcibios_write_config_byte(bus, fn, PCI_LATENCY_TIMER, 0x20); 
+				goto hpt343_jump_in;
+			} else {
+				printk("ide: HPTXXX did == 0x%04X unsupport chipset error.\n", device);
+				return;
+			}
+		case PCI_VENDOR_ID_PROMISE:
+			/*
+			 *  I have been able to make my Promise Ultra33 UDMA card change class.
+			 *  It has reported as both PCI_CLASS_STORAGE_RAID and PCI_CLASS_STORAGE_IDE.
+			 *  Since the PCI_CLASS_STORAGE_RAID mode should automatically mirror the
+			 *  two halves of the PCI_CONFIG register data, but sometimes it forgets.
+			 *  Thus we guarantee that they are identical, with a quick check and
+			 *  correction if needed.
+			 *  PDC20246 (primary) PDC20247 (secondary) IDE hwif's.
+			 *
+			 *  PDC20262 Promise Ultra66 UDMA.
+			 *
+			 *  Note that Promise "stories,fibs,..." about this device not being
+			 *  capable of ATAPI and AT devices.
+			 */
+			if (class != PCI_CLASS_STORAGE_IDE) {
+				unsigned char irq_mirror = 0;
+
+				pcibios_read_config_byte(bus, fn, (PCI_INTERRUPT_LINE)|0x80, &irq_mirror);
+				if (irq != irq_mirror) {
+					pcibios_write_config_byte(bus, fn, (PCI_INTERRUPT_LINE)|0x80, irq);
+				}
+			}
+		case PCI_VENDOR_ID_ARTOP:
+			/*	PCI_CLASS_STORAGE_SCSI == class	*/
+			/*
+			 *  I have found that by stroking rom_enable_bit on both the AEC6210U/UF and
+			 *  PDC20246 controller cards, the features desired are almost guaranteed
+			 *  to be enabled and compatible.  This ROM may not be registered in the
+			 *  config data, but it can be turned on.  Registration failure has only
+			 *  been observed if and only if Linux sets up the pci_io_address in the
+			 *  0x6000 range.  If they are setup in the 0xef00 range it is reported.
+			 *  WHY??? got me.........
+			 */
+hpt343_jump_in:
+			printk("ide: %s UDMA Bus Mastering ",
+				(device == PCI_DEVICE_ID_ARTOP_ATP850UF) 		? "AEC6210" :
+				(device == PCI_DEVICE_ID_PROMISE_20246)  		? "PDC20246" :
+				(device == PCI_DEVICE_ID_PROMISE_20262)  		? "PDC20262" :
+				(hpt34x_flag && (device == PCI_DEVICE_ID_TTI_HPT343))	? "HPT345" :
+				(device == PCI_DEVICE_ID_TTI_HPT343)     		? "HPT343" : "UNKNOWN");
+			pcibios_read_config_dword(bus, fn, PCI_ROM_ADDRESS, &addressbios);
+			if (addressbios) {
+				pcibios_write_config_byte(bus, fn, PCI_ROM_ADDRESS, addressbios | PCI_ROM_ADDRESS_ENABLE);
+				printk("with ROM enabled at 0x%08x", addressbios);
+			}
+			/*
+			 *  This was stripped out of 2.1.XXX kernel code and parts from a patch called
+			 *  promise_update.  This finds the PCI_BASE_ADDRESS spaces and makes them
+			 *  available for configuration later.
+			 *  PCI_BASE_ADDRESS_0  hwif0->io_base
+			 *  PCI_BASE_ADDRESS_1  hwif0->ctl_port
+			 *  PCI_BASE_ADDRESS_2  hwif1->io_base
+			 *  PCI_BASE_ADDRESS_3  hwif1->ctl_port
+			 *  PCI_BASE_ADDRESS_4  bmiba
+			 */
+			memset(io, 0, 6 * sizeof(unsigned short));
+			for (reg = PCI_BASE_ADDRESS_0; reg <= PCI_BASE_ADDRESS_5; reg += 4) {
+				pcibios_read_config_dword(bus, fn, reg, &tmp);
+				if (tmp & PCI_BASE_ADDRESS_SPACE_IO)
+					io[count++] = tmp & PCI_BASE_ADDRESS_IO_MASK;
+			}
+			break;
+		case PCI_VENDOR_ID_AL:
+			save_flags(flags);
+			cli();
+			for (index = 0; !pcibios_find_device (PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533, index, &bridgebus, &bridgefn); ++index) {
+				bridgeset = setup_aladdin(bus, fn);
+			}
+			restore_flags(flags);
+			printk("ide: ALI15X3 (dual FIFO) DMA Bus Mastering IDE ");
+			break;
+		default:
+			return;
+	}
+
+	printk("\n    Controller on PCI bus %d function %d\n", bus, fn);
 
-	printk("ide: i82371 PIIX (Triton) on PCI bus %d function %d\n", bus, fn);
 	/*
 	 * See if IDE and BM-DMA features are enabled:
 	 */
-	if ((rc = pcibios_read_config_word(bus, fn, 0x04, &pcicmd)))
+	if ((rc = pcibios_read_config_word(bus, fn, PCI_COMMAND, &pcicmd)))
 		goto quit;
 	if ((pcicmd & 1) == 0)  {
 		printk("ide: ports are not enabled (BIOS)\n");
@@ -426,21 +649,29 @@ void ide_init_triton (byte bus, byte fn)
 		 */
 		int try_again = 1;
 		do {
-			if ((rc = pcibios_read_config_dword(bus, fn, 0x20, &bmiba)))
+			if ((rc = pcibios_read_config_dword(bus, fn, PCI_BASE_ADDRESS_4, &bmiba)))
 				goto quit;
 			bmiba &= 0xfff0;	/* extract port base address */
 			if (bmiba) {
 				dma_enabled = 1;
 				break;
 			} else {
-				printk("ide: BM-DMA base register is invalid (0x%04x, PnP BIOS problem)\n", bmiba);
-				if (inb(DEFAULT_BMIBA) != 0xff || !try_again)
+                                printk("ide: BM-DMA base register is invalid (0x%04x, PnP BIOS problem)\n", bmiba);
+                                if (inb(((vendor == PCI_VENDOR_ID_AL) ? DEFAULT_BMALIBA :
+					 (vendor == PCI_VENDOR_ID_VIA) ? DEFAULT_BMCRBA :
+									DEFAULT_BMIBA)) != 0xff || !try_again)
 					break;
-				printk("ide: setting BM-DMA base register to 0x%04x\n", DEFAULT_BMIBA);
-				if ((rc = pcibios_write_config_word(bus, fn, 0x04, pcicmd&~1)))
+				printk("ide: setting BM-DMA base register to 0x%04x\n",
+					((vendor == PCI_VENDOR_ID_AL) ? DEFAULT_BMALIBA :
+					 (vendor == PCI_VENDOR_ID_VIA) ? DEFAULT_BMCRBA :
+									DEFAULT_BMIBA));
+				if ((rc = pcibios_write_config_word(bus, fn, PCI_COMMAND, pcicmd&~1)))
 					goto quit;
-				rc = pcibios_write_config_dword(bus, fn, 0x20, DEFAULT_BMIBA|1);
-				if (pcibios_write_config_word(bus, fn, 0x04, pcicmd|5) || rc)
+				rc = pcibios_write_config_dword(bus, fn, 0x20,
+					((vendor == PCI_VENDOR_ID_AL) ? DEFAULT_BMALIBA :
+					 (vendor == PCI_VENDOR_ID_VIA) ? DEFAULT_BMCRBA :
+									DEFAULT_BMIBA)|1);
+				if (pcibios_write_config_word(bus, fn, PCI_COMMAND, pcicmd|5) || rc)
 					goto quit;
 			}
 		} while (try_again--);
@@ -449,89 +680,308 @@ void ide_init_triton (byte bus, byte fn)
 	/*
 	 * See if ide port(s) are enabled
 	 */
-	if ((rc = pcibios_read_config_dword(bus, fn, 0x40, &timings)))
-		goto quit;
-	if (!(timings & 0x80008000)) {
-		printk("ide: neither port is enabled\n");
+	if ((rc = pcibios_read_config_dword(bus, fn,
+		(vendor == PCI_VENDOR_ID_PROMISE) ? 0x50 : 
+		(vendor == PCI_VENDOR_ID_ARTOP) ? 0x54 :
+		(vendor == PCI_VENDOR_ID_SI) ? 0x48 :
+		(vendor == PCI_VENDOR_ID_AL) ? 0x08 :
+		0x40, &timings)))
 		goto quit;
-	}
+	/*
+	 * We do a vendor check since the Ultra33/66 and AEC6210
+	 * holds their timings in a different location.
+	 */
+#if 0
+	printk("ide: timings == %08x\n", timings);
+#endif
+	/*
+	 *  The switch preserves some stuff that was original.
+	 */
+	switch(vendor) {
+		case PCI_VENDOR_ID_INTEL:
+			if (!(timings & 0x80008000)) {
+				printk("ide: INTEL: neither port is enabled\n");
+				goto quit;
+			}
+			break;
+		case PCI_VENDOR_ID_VIA:
+			if(!(timings & 0x03)) {
+				printk("ide: VIA: neither port is enabled\n");
+				goto quit;
+			}
+			break;
+		case PCI_VENDOR_ID_AL:
+			timings <<= 16;
+			timings >>= 24;
+			if (!(timings & 0x30)) {
+				printk("ide: ALI15X3: neither port is enabled\n");
+				goto quit;
+			}
+			break;
+		case PCI_VENDOR_ID_SI:
+			timings <<= 8;
+			timings >>= 24;
+			if (!(timings & 0x06)) {
+				printk("ide: SIS5513: neither port is enabled\n");
+				goto quit;
+			}
+			break;
+		case PCI_VENDOR_ID_PROMISE:
+			printk("    (U)DMA Burst Bit %sABLED " \
+				"Primary %s Mode " \
+				"Secondary %s Mode.\n",
+				(inb(bmiba + 0x001f) & 1) ? "EN" : "DIS",
+				(inb(bmiba + 0x001a) & 1) ? "MASTER" : "PCI",
+				(inb(bmiba + 0x001b) & 1) ? "MASTER" : "PCI" );
+#if 0
+			if (!(inb(bmiba + 0x001f) & 1)) {
+				outb(inb(bmiba + 0x001f)|0x01, (bmiba + 0x001f));
+				printk("    (U)DMA Burst Bit Forced %sABLED.\n",
+					(inb(bmiba + 0x001f) & 1) ? "EN" : "DIS");
+			}
+#endif
+			break;
+		case PCI_VENDOR_ID_ARTOP:
+		case PCI_VENDOR_ID_TTI:
+                default:
+                        break;
+        }
 
 	/*
 	 * Save the dma_base port addr for each interface
 	 */
 	for (h = 0; h < MAX_HWIFS; ++h) {
+		ide_hwif_t *hwif = &ide_hwifs[h];
+		byte channel = ((h == 1) || (h == 3) || (h == 5)) ? 1 : 0;
+
+		/*
+		 *  This prevents the first contoller from accidentally
+		 *  initalizing the hwif's that it does not use and block
+		 *  an off-board ide-pci from getting in the game.
+		 */
+		if ((step_count >= 2) || (pass_count >= 2)) {
+			goto quit;
+		}
+
+#if 0
+		if (hwif->chipset == ide_unknown)
+			printk("ide: index == %d channel(%d)\n", h, channel);
+#endif
+
+#ifdef CONFIG_BLK_DEV_OFFBOARD
+		/*
+		 *  This is a forced override for the onboard ide controller
+		 *  to be enabled, if one chooses to have an offboard ide-pci
+		 *  card as the primary booting device.  This beasty is
+		 *  for offboard UDMA upgrades with hard disks, but saving
+		 *  the onboard DMA2 controllers for CDROMS, TAPES, ZIPS, etc...
+		 */
+		if (((vendor == PCI_VENDOR_ID_INTEL) ||
+		     (vendor == PCI_VENDOR_ID_SI) ||
+		     (vendor == PCI_VENDOR_ID_VIA) ||
+		     (vendor == PCI_VENDOR_ID_AL)) && (h >= 2)) {
+			hwif->io_base	= channel ? 0x170 : 0x1f0;
+			hwif->ctl_port	= channel ? 0x376 : 0x3f6;
+			hwif->irq	= channel ? 15 : 14;
+			hwif->noprobe	= 0;
+		}
+#endif /* CONFIG_BLK_DEV_OFFBOARD */
+		/*
+		 *  If the chipset is listed as "ide_unknown", lets get a
+		 *  hwif while they last.  This does the first check on
+		 *  the current availability of the ide_hwifs[h] in question.
+		 */
+		if (hwif->chipset != ide_unknown) {
+			continue;
+		} else if (vendor == PCI_VENDOR_ID_INTEL) {
+			unsigned short time;
 #ifdef DISPLAY_TRITON_TIMINGS
-		byte s_clks, r_clks;
-		unsigned short devid;
+			byte s_clks, r_clks;
+			unsigned short devid;
 #endif /* DISPLAY_TRITON_TIMINGS */
-		ide_hwif_t *hwif = &ide_hwifs[h];
-		unsigned short time;
-		if (hwif->io_base == 0x1f0) {
-			time = timings & 0xffff;
-			if ((time & 0x8000) == 0)	/* interface enabled? */
-				continue;
-			hwif->chipset = ide_triton;
-			if (dma_enabled)
-				init_triton_dma(hwif, bmiba);
-		} else if (hwif->io_base == 0x170) {
-			time = timings >> 16;
-			if ((time & 0x8000) == 0)	/* interface enabled? */
+			pass_count++;
+			if (hwif->io_base == 0x1f0) {
+				time = timings & 0xffff;
+				if ((time & 0x8000) == 0)	/* interface enabled? */
+					continue;
+				hwif->chipset = ide_triton;
+				if (dma_enabled)
+					init_triton_dma(hwif, bmiba);
+				step_count++;
+			} else if (hwif->io_base == 0x170) {
+				time = timings >> 16;
+				if ((time & 0x8000) == 0)	/* interface enabled? */
+					continue;
+				hwif->chipset = ide_triton;
+				if (dma_enabled)
+					init_triton_dma(hwif, bmiba + 8);
+				step_count++;
+			} else {
 				continue;
-			hwif->chipset = ide_triton;
-			if (dma_enabled)
-				init_triton_dma(hwif, bmiba + 8);
-		} else
-			continue;
+			}
 #ifdef DISPLAY_TRITON_TIMINGS
-		s_clks = ((~time >> 12) & 3) + 2;
-		r_clks = ((~time >>  8) & 3) + 1;
-		printk("    %s timing: (0x%04x) sample_CLKs=%d, recovery_CLKs=%d\n",
-		 hwif->name, time, s_clks, r_clks);
-		if ((time & 0x40) && !pcibios_read_config_word(bus, fn, 0x02, &devid)
-		 && devid == PCI_DEVICE_ID_INTEL_82371SB_1)
-		{
-			byte stime;
-			if (pcibios_read_config_byte(bus, fn, 0x44, &stime)) {
-				if (hwif->io_base == 0x1f0) {
-					s_clks = ~stime >> 6;
-					r_clks = ~stime >> 4;
+			s_clks = ((~time >> 12) & 3) + 2;
+			r_clks = ((~time >>  8) & 3) + 1;
+			printk("    %s timing: (0x%04x) sample_CLKs=%d, recovery_CLKs=%d\n",
+				hwif->name, time, s_clks, r_clks);
+			if ((time & 0x40) && !pcibios_read_config_word(bus, fn, PCI_DEVICE_ID, &devid)
+				&& devid == PCI_DEVICE_ID_INTEL_82371SB_1) {
+				byte stime;
+				if (pcibios_read_config_byte(bus, fn, 0x44, &stime)) {
+					if (hwif->io_base == 0x1f0) {
+						s_clks = ~stime >> 6;
+						r_clks = ~stime >> 4;
+					} else {
+						s_clks = ~stime >> 2;
+						r_clks = ~stime;
+					}
+					s_clks = (s_clks & 3) + 2;
+					r_clks = (r_clks & 3) + 1;
+					printk("                   slave: sample_CLKs=%d, recovery_CLKs=%d\n",
+						s_clks, r_clks);
+				}
+			}
+			print_triton_drive_flags (0, time & 0xf);
+			print_triton_drive_flags (1, (time >> 4) & 0xf);
+#endif /* DISPLAY_TRITON_TIMINGS */
+		} else if (vendor == PCI_VENDOR_ID_SI) {
+			pass_count++;
+			if (hwif->io_base == 0x1f0) {
+				if ((timings & 0x02) == 0)
+					continue;
+				hwif->chipset = ide_triton;
+				if (dma_enabled)
+					init_triton_dma(hwif, bmiba);
+				step_count++;
+			} else if (hwif->io_base == 0x170) {
+				if ((timings & 0x04) == 0)
+					continue;
+				hwif->chipset = ide_triton;
+				if (dma_enabled)
+					init_triton_dma(hwif, bmiba + 8);
+				step_count++;
+			} else {
+				continue;
+			}
+		} else if (vendor == PCI_VENDOR_ID_VIA) {
+			pass_count++;
+			if (hwif->io_base == 0x1f0) {
+				if ((timings & 0x02) == 0)
+					continue;
+				hwif->chipset = ide_triton;
+				if (dma_enabled)
+					init_triton_dma(hwif, bmiba);
+				if (set_via_timings(bus, fn, 0xc0, 0xa0))
+					goto quit;
+#ifdef DISPLAY_APOLLO_TIMINGS
+				proc_register_dynamic(&proc_root, &via_proc_entry);
+#endif /* DISPLAY_APOLLO_TIMINGS */
+				step_count++;
+			} else if (hwif->io_base == 0x170) {
+				if ((timings & 0x01) == 0)
+					continue;
+				hwif->chipset = ide_triton;
+				if (dma_enabled)
+					init_triton_dma(hwif, bmiba + 8);
+				if (set_via_timings(bus, fn, 0x30, 0x50))
+					goto quit;
+				step_count++;
+			} else {
+				continue;
+			}
+		} else if (vendor == PCI_VENDOR_ID_AL) {
+			byte ideic, inmir;
+			byte irq_routing_table[] = { -1,  9, 3, 10, 4,  5, 7,  6,
+						      1, 11, 0, 12, 0, 14, 0, 15 };
+
+			if (bridgeset) {
+				pcibios_read_config_byte(bridgebus, bridgefn, 0x58, &ideic);
+				ideic = ideic & 0x03;
+				if ((channel && ideic == 0x03) || (!channel && !ideic)) {
+					pcibios_read_config_byte(bridgebus, bridgefn, 0x44, &inmir);
+					inmir = inmir & 0x0f;
+					hwif->irq = irq_routing_table[inmir];
+				} else if (channel && !(ideic & 0x01)) {
+					pcibios_read_config_byte(bridgebus, bridgefn, 0x75, &inmir);
+					inmir = inmir & 0x0f;
+					hwif->irq = irq_routing_table[inmir];
+				}
+			}
+			pass_count++;
+			if (hwif->io_base == 0x1f0) {
+				if ((timings & 0x20) == 0)
+					continue;
+				hwif->chipset = ide_triton;
+				if (dma_enabled)
+					init_triton_dma(hwif, bmiba);
+				outb(inb(bmiba+2) & 0x60, bmiba+2);
+				if (inb(bmiba+2) & 0x80)
+					printk("ALI15X3: simplex device: DMA forced\n");
+#ifdef DISPLAY_ALI15X3_TIMINGS
+				proc_register_dynamic(&proc_root, &ali_proc_entry);
+#endif /* DISPLAY_ALI15X3_TIMINGS */
+				step_count++;
+			} else if (hwif->io_base == 0x170) {
+				if ((timings & 0x10) == 0)
+					continue;
+				hwif->chipset = ide_triton;
+				if (dma_enabled)
+					init_triton_dma(hwif, bmiba + 8);
+				outb(inb(bmiba+10) & 0x60, bmiba+10);
+				if (inb(bmiba+10) & 0x80)
+					printk("ALI15X3: simplex device: DMA forced\n");
+				step_count++;
+			} else {
+				continue;
+			}
+		} else if ((vendor == PCI_VENDOR_ID_PROMISE) ||
+			   (vendor == PCI_VENDOR_ID_ARTOP) ||
+			   (vendor == PCI_VENDOR_ID_TTI)) {
+			pass_count++;
+			if (vendor == PCI_VENDOR_ID_TTI) {
+				if ((!hpt34x_flag) && (h < 2)) {
+					goto quit;
+				} else if (hpt34x_flag) {
+					hwif->io_base	= channel ? (bmiba + 0x28) : (bmiba + 0x20);
+					hwif->ctl_port	= channel ? (bmiba + 0x3e) : (bmiba + 0x36);
 				} else {
-					s_clks = ~stime >> 2;
-					r_clks = ~stime;
+					goto io_temps;
+				}
+			} else {
+io_temps:
+				tmp		= channel ? 2 : 0;
+				hwif->io_base	= io[tmp];
+				hwif->ctl_port	= io[tmp + 1] + 2;
+			}
+			hwif->irq = irq;
+			hwif->noprobe = 0;
+
+			if (device == PCI_DEVICE_ID_ARTOP_ATP850UF) {
+				hwif->serialized = 1;
+			}
+
+			if ((vendor == PCI_VENDOR_ID_PROMISE) ||
+			    (vendor == PCI_VENDOR_ID_TTI)) {
+				set_promise_hpt343_extra(device, bmiba);
+			}
+
+			if (dma_enabled) {
+				if ((!check_region(bmiba, 8)) && (!channel)) {
+					hwif->chipset = ((vendor == PCI_VENDOR_ID_TTI) && !hpt34x_flag) ? ide_hpt343 :
+							 (device == PCI_DEVICE_ID_PROMISE_20262) ? ide_ultra66 : ide_udma;
+					init_triton_dma(hwif, bmiba);
+					step_count++;
+				} else if ((!check_region((bmiba + 0x08), 8)) && (channel)) {
+					hwif->chipset = ((vendor == PCI_VENDOR_ID_TTI) && !hpt34x_flag) ? ide_hpt343 :
+							 (device == PCI_DEVICE_ID_PROMISE_20262) ? ide_ultra66 : ide_udma;
+					init_triton_dma(hwif, bmiba + 8);
+					step_count++;
+				} else {
+					continue;
 				}
-				s_clks = (s_clks & 3) + 2;
-				r_clks = (r_clks & 3) + 1;
-				printk("                   slave: sample_CLKs=%d, recovery_CLKs=%d\n",
-		 			s_clks, r_clks);
 			}
 		}
-		print_triton_drive_flags (0, time & 0xf);
-		print_triton_drive_flags (1, (time >> 4) & 0xf);
-#endif /* DISPLAY_TRITON_TIMINGS */
 	}
 
-quit: if (rc) printk("ide: pcibios access failed - %s\n", pcibios_strerror(rc));
-}
-
-void ide_init_promise (byte bus, byte fn, ide_hwif_t *hwif0, ide_hwif_t *hwif1, unsigned short dma)
-{
-	int rc;
-	unsigned short pcicmd;
-	unsigned int bmiba = 0;
-
-	printk("ide: Enabling DMA for Promise Technology IDE Ultra-DMA 33 on PCI bus %d function %d, port 0x%04x\n", bus, fn, dma);
-	if ((rc = pcibios_read_config_word(bus, fn, 0x04, &pcicmd)) || (pcicmd & 1) == 0 || (pcicmd & 4) == 0)
-		goto abort;
-	if ((rc = pcibios_read_config_dword(bus, fn, 0x20, &bmiba)))
-		goto abort;
-	bmiba &= 0xfff0;	/* extract port base address */
-	if (bmiba != dma || !bmiba)
-		goto abort;
-	hwif0->chipset = ide_promise_udma;
-	hwif1->chipset = ide_promise_udma;
-	init_triton_dma(hwif0, bmiba);
-	init_triton_dma(hwif1, bmiba + 0x08);
-	return;
-abort:
-	printk(KERN_WARNING "ide: Promise/33 not configured correctly (BIOS)\n");
+	quit: if (rc) printk("ide: pcibios access failed - %s\n", pcibios_strerror(rc));
 }
Index: b/linux/src/include/linux/hdreg.h
===================================================================
--- a/linux/src/include/linux/hdreg.h
+++ b/linux/src/include/linux/hdreg.h
@@ -92,11 +92,12 @@ struct hd_geometry {
 #define HDIO_GETGEO		0x0301	/* get device geometry */
 #define HDIO_GET_UNMASKINTR	0x0302	/* get current unmask setting */
 #define HDIO_GET_MULTCOUNT	0x0304	/* get current IDE blockmode setting */
-#define HDIO_GET_IDENTITY 	0x0307	/* get IDE identification info */
+#define HDIO_OBSOLETE_IDENTITY	0x0307	/* OBSOLETE, DO NOT USE: returns 142 bytes */
 #define HDIO_GET_KEEPSETTINGS 	0x0308	/* get keep-settings-on-reset flag */
 #define HDIO_GET_32BIT 		0x0309	/* get current io_32bit setting */
 #define HDIO_GET_NOWERR		0x030a	/* get ignore-write-error flag */
 #define HDIO_GET_DMA		0x030b	/* get use-dma flag */
+#define HDIO_GET_IDENTITY	0x030d	/* get IDE identification info */
 #define HDIO_DRIVE_CMD		0x031f	/* execute a special drive command */
 
 /* hd/ide ctl's that pass (arg) non-ptr values are numbered 0x032n/0x033n */
@@ -166,14 +167,54 @@ struct hd_driveid {
 	unsigned short  word79;
 	unsigned short  word80;
 	unsigned short  word81;
-	unsigned short  word82;
-	unsigned short  word83;
+	unsigned short  command_sets;	/* bits 0:Smart 1:Security 2:Removable 3:PM */
+	unsigned short  word83;		/* bits 14:Smart Enabled 13:0 zero */
 	unsigned short  word84;
 	unsigned short  word85;
 	unsigned short  word86;
 	unsigned short  word87;
 	unsigned short  dma_ultra;
-	unsigned short  reserved[167];
+	unsigned short	word89;		/* reserved (word 89) */
+	unsigned short	word90;		/* reserved (word 90) */
+	unsigned short	word91;		/* reserved (word 91) */
+	unsigned short	word92;		/* reserved (word 92) */
+	unsigned short	word93;		/* reserved (word 93) */
+	unsigned short	word94;		/* reserved (word 94) */
+	unsigned short	word95;		/* reserved (word 95) */
+	unsigned short	word96;		/* reserved (word 96) */
+	unsigned short	word97;		/* reserved (word 97) */
+	unsigned short	word98;		/* reserved (word 98) */
+	unsigned short	word99;		/* reserved (word 99) */
+	unsigned short	word100;	/* reserved (word 100) */
+	unsigned short	word101;	/* reserved (word 101) */
+	unsigned short	word102;	/* reserved (word 102) */
+	unsigned short	word103;	/* reserved (word 103) */
+	unsigned short	word104;	/* reserved (word 104) */
+	unsigned short	word105;	/* reserved (word 105) */
+	unsigned short	word106;	/* reserved (word 106) */
+	unsigned short	word107;	/* reserved (word 107) */
+	unsigned short	word108;	/* reserved (word 108) */
+	unsigned short	word109;	/* reserved (word 109) */
+	unsigned short	word110;	/* reserved (word 110) */
+	unsigned short	word111;	/* reserved (word 111) */
+	unsigned short	word112;	/* reserved (word 112) */
+	unsigned short	word113;	/* reserved (word 113) */
+	unsigned short	word114;	/* reserved (word 114) */
+	unsigned short	word115;	/* reserved (word 115) */
+	unsigned short	word116;	/* reserved (word 116) */
+	unsigned short	word117;	/* reserved (word 117) */
+	unsigned short	word118;	/* reserved (word 118) */
+	unsigned short	word119;	/* reserved (word 119) */
+	unsigned short	word120;	/* reserved (word 120) */
+	unsigned short	word121;	/* reserved (word 121) */
+	unsigned short	word122;	/* reserved (word 122) */
+	unsigned short	word123;	/* reserved (word 123) */
+	unsigned short	word124;	/* reserved (word 124) */
+	unsigned short	word125;	/* reserved (word 125) */
+	unsigned short	word126;	/* reserved (word 126) */
+	unsigned short	word127;	/* reserved (word 127) */
+	unsigned short	security;	/* bits 0:suuport 1:enabled 2:locked 3:frozen */
+	unsigned short	reserved[127];
 };
 
 #ifdef __KERNEL__
Index: b/linux/configfrag.ac
===================================================================
--- a/linux/configfrag.ac
+++ b/linux/configfrag.ac
@@ -140,6 +140,11 @@ AC_Linux_DRIVER_qemu([ide],
   [IDE disk controllers],
   [CONFIG_BLK_DEV_IDE])
 
+AC_ARG_ENABLE([ide-forcedma],
+  AS_HELP_STRING([--enable-ide-forcedma], [enable forced use of DMA on IDE]),
+  [test x"$enableval" = xno ||
+   AC_DEFINE([CONFIG_BLK_DEV_FORCE_DMA], [1], [Force DMA on IDE block devices])])
+
 dnl SCSI controllers.
 
 AC_Linux_DRIVER([53c78xx],
